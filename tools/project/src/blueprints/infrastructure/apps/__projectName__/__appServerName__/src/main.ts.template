import express from 'express';
import { ApolloServer } from '@apollo/server';
import { expressMiddleware } from '@apollo/server/express4';
import { v4 as uuidv4 } from 'uuid';
import cors from 'cors';
import http from 'http';
import amqp from 'amqplib';
import { json } from 'body-parser';
import { makeExecutableSchema } from '@graphql-tools/schema';

// Memoria para almacenar nuestros procesos pendientes
const processes = new Map<string, {
  id: string,
  content: string,
  completed: boolean,
  result?: string
}>();

// Definici√≥n del esquema GraphQL
const typeDefs = `#graphql
  type Process {
    id: ID!
    content: String!
    completed: Boolean!
    result: String
  }

  type Query {
    getProcess(id: ID!): Process
    healthCheck: String!
  }

  type Mutation {
    createProcess(content: String!): Process!
  }
`;

// Implementaci√≥n de resolvers
const resolvers = {
  Query: {
    healthCheck: () => "¬°El servidor est√° funcionando correctamente!",
    getProcess: (_: any, { id }: { id: string }) => {
      if (!processes.has(id)) {
        throw new Error(`Proceso con ID ${id} no encontrado`);
      }
      return processes.get(id);
    }
  },
  Mutation: {
    createProcess: async (_: any, { content }: { content: string }) => {
      const id = uuidv4();

      const taskProcess = {
        id,
        content,
        completed: false
      };

      processes.set(id, taskProcess);
      console.log(`üìù Creado nuevo proceso: ${id}`);

      // Usar la misma URL que en el consumidor
      const rabbitmqUrl = process.env.RABBITMQ_URL || 'amqp://guest:guest@rabbitmq:5672';

      // Enviar a RabbitMQ
      try {
        console.log(`üîÑ Conectando a RabbitMQ para enviar tarea: ${rabbitmqUrl}`);
        const connection = await amqp.connect(rabbitmqUrl);
        const channel = await connection.createChannel();

        const queue = 'worker-queue';
        await channel.assertQueue(queue, { durable: true });

        // Verificar estado de la cola
        const queueInfo = await channel.checkQueue(queue);
        console.log(`Cola ${queue} - mensajes: ${queueInfo.messageCount}, consumidores: ${queueInfo.consumerCount}`);

        // Enviar con persistencia
        const sent = channel.sendToQueue(
          queue,
          Buffer.from(JSON.stringify({ id, content })),
          { persistent: true }
        );

        if (sent) {
          console.log(`‚úÖ Mensaje enviado a cola ${queue} con ID: ${id}`);
        } else {
          console.warn(`‚ö†Ô∏è Canal lleno, no se pudo enviar mensaje inmediatamente`);
        }

        await channel.close();
        await connection.close();
      } catch (error) {
        console.error('‚ùå Error al enviar a RabbitMQ:', error);
        // Podr√≠amos marcar el proceso como fallido si es necesario
      }

      return taskProcess;
    }
  }
};

// Configuraci√≥n para recibir mensajes de RabbitMQ
async function setupRabbitMQConsumer() {
  const MAX_RETRIES = 5;
  let retries = MAX_RETRIES;
  let connection = null;
  let channel = null;

  const connectWithRetry = async () => {
    while (retries > 0) {
      try {
        // Usar la misma URL que en worker (rabbitmq en lugar de localhost)
        const rabbitmqUrl = process.env.RABBITMQ_URL || 'amqp://guest:guest@rabbitmq:5672';
        console.log(`Intentando conectar a RabbitMQ: ${rabbitmqUrl}`);

        connection = await amqp.connect(rabbitmqUrl);
        console.log('‚úÖ Conexi√≥n a RabbitMQ establecida');

        // Manejar eventos de conexi√≥n
        connection.on('error', (err) => {
          console.error('‚ùå Error en la conexi√≥n RabbitMQ:', err);
          // Intentar reconectar despu√©s de un error
          setTimeout(connectWithRetry, 5000);
        });

        connection.on('close', () => {
          console.warn('‚ö†Ô∏è Conexi√≥n RabbitMQ cerrada, intentando reconectar...');
          // Intentar reconectar si se cierra
          setTimeout(connectWithRetry, 5000);
        });

        // Crear canal
        channel = await connection.createChannel();
        console.log('‚úÖ Canal RabbitMQ creado');

        // Configurar la cola
        const queue = 'server-queue';
        const queueInfo = await channel.assertQueue(queue, { durable: true });
        console.log(`‚úÖ Cola ${queue} configurada:`, queueInfo);

        // Verificar estado actual de la cola
        const checkInfo = await channel.checkQueue(queue);
        console.log(`‚úÖ Estado actual de cola ${queue}:`, {
          mensajes: checkInfo.messageCount,
          consumidores: checkInfo.consumerCount
        });

        console.log(`[*] Esperando mensajes en ${queue}`);

        // Configurar consumidor
        const consumer = await channel.consume(queue, (msg) => {
          if (msg) {
            try {
              console.log(`üì® Mensaje recibido de RabbitMQ:`, msg.content.toString());
              const content = JSON.parse(msg.content.toString());
              console.log(`[x] Procesando respuesta para proceso ${content.id}`);

              if (processes.has(content.id)) {
                const process = processes.get(content.id)!;
                console.log(`Estado anterior del proceso ${content.id}:`, process);

                process.completed = true;
                process.result = content.result;
                processes.set(content.id, process);

                console.log(`‚úÖ Proceso ${content.id} actualizado a completado`);
              } else {
                console.warn(`‚ö†Ô∏è Recibido mensaje para proceso desconocido: ${content.id}`);
              }

              // Confirmar procesamiento
              channel.ack(msg);
              console.log(`‚úÖ Mensaje confirmado`);
            } catch (error) {
              console.error('‚ùå Error procesando mensaje:', error);
              channel.nack(msg, false, true); // Reintentar en caso de error
            }
          }
        });

        console.log(`‚úÖ Consumidor configurado con tag: ${consumer.consumerTag}`);
        return true;
      } catch (error) {
        retries--;
        console.error(`‚ùå Error al configurar RabbitMQ (intentos restantes: ${retries}):`, error);

        // Limpiar conexi√≥n y canal si existen
        if (channel) try { await channel.close(); } catch {}
        if (connection) try { await connection.close(); } catch {}

        if (retries <= 0) {
          console.error('‚ùå Se agotaron los reintentos para conectar a RabbitMQ');
          throw error;
        }

        // Esperar antes de reintentar
        console.log(`‚è≥ Esperando 5 segundos antes de reintentar...`);
        await new Promise(resolve => setTimeout(resolve, 5000));
      }
    }
  };

  return connectWithRetry();
}

// Inicializaci√≥n del servidor
async function startServer() {
  const app = express();
  const httpServer = http.createServer(app);

  // Endpoint para health check (REST)
  app.get('/health', (req, res) => {
    res.json({ status: 'ok', timestamp: new Date().toISOString() });
  });

  // Servidor Apollo/GraphQL
  const schema = makeExecutableSchema({ typeDefs, resolvers });
  const server = new ApolloServer({ schema });
  await server.start();

  // Crea un router para GraphQL
  const graphqlRouter = express.Router();
  graphqlRouter.use(cors(), json());
  graphqlRouter.use(expressMiddleware(server) as any);

  // Monta el router en la app
  app.use('/graphql', graphqlRouter);

  // Iniciar servidor
  const PORT = process.env.PORT || 4000;
  httpServer.listen(PORT, () => {
    console.log(`üöÄ Servidor listo en http://localhost:${PORT}`);
    console.log(`üìä GraphQL disponible en http://localhost:${PORT}/graphql`);
  });

  // Configurar receptor de RabbitMQ
  await setupRabbitMQConsumer();
}

startServer().catch(err => {
  console.error('Error al iniciar el servidor:', err);
});
