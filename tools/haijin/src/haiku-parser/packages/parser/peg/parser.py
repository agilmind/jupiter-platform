#!/usr/bin/env python3.8
# @generated by my_pegen from blocks.gram

import ast
import sys
import tokenize

from typing import Any, Optional

from pegen.parser import memoize, memoize_left_rec, logger, Parser

from ast_builder import Builder
builder = Builder()

# Keywords and soft keywords are listed at the end of the parser definition.
class BlocksParser(Parser):

    @memoize
    def NL(self) -> Optional[Any]:
        # NL: NEWLINE
        mark = self._mark()
        if (
            (_newline := self.expect('NEWLINE'))
        ):
            return _newline
        self._reset(mark)
        return None

    @memoize
    def start(self) -> Optional[Any]:
        # start: module? NL? $
        mark = self._mark()
        if (
            (m := self.module(),)
            and
            (opt := self.NL(),)
            and
            (_endmarker := self.expect('ENDMARKER'))
        ):
            return builder . root ( m or [] )
        self._reset(mark)
        return None

    @memoize
    def module(self) -> Optional[Any]:
        # module: NL.definition+
        mark = self._mark()
        if (
            (a := self._gather_1())
        ):
            return a
        self._reset(mark)
        return None

    @memoize
    def definition(self) -> Optional[Any]:
        # definition: import_def | block
        mark = self._mark()
        if (
            (a := self.import_def())
        ):
            return a
        self._reset(mark)
        if (
            (a := self.block())
        ):
            return builder . root_block ( a )
        self._reset(mark)
        return None

    @memoize
    def block(self) -> Optional[Any]:
        # block: NAME NL? '{' NL? [NL.block+ NL?] '}' | NAME NL? ':' NL? expression [NL? '{' NL? [NL.block+ NL?] '}'] | NAME
        mark = self._mark()
        if (
            (a := self.name())
            and
            (opt := self.NL(),)
            and
            (literal := self.expect('{'))
            and
            (opt_1 := self.NL(),)
            and
            (b := self._tmp_3(),)
            and
            (literal_1 := self.expect('}'))
        ):
            return builder . build_block ( a , None , b )
        self._reset(mark)
        if (
            (a := self.name())
            and
            (opt := self.NL(),)
            and
            (literal := self.expect(':'))
            and
            (opt_1 := self.NL(),)
            and
            (b := self.expression())
            and
            (c := self._tmp_4(),)
        ):
            return builder . build_block ( a , b , c or [] )
        self._reset(mark)
        if (
            (a := self.name())
        ):
            return builder . build_block ( a , None , [] )
        self._reset(mark)
        return None

    @memoize
    def import_def(self) -> Optional[Any]:
        # import_def: "from" STRING "import" ','.import_member+
        mark = self._mark()
        if (
            (literal := self.expect("from"))
            and
            (a := self.string())
            and
            (literal_1 := self.expect("import"))
            and
            (b := self._gather_5())
        ):
            return builder . build_import ( a , b )
        self._reset(mark)
        return None

    @memoize
    def import_member(self) -> Optional[Any]:
        # import_member: NAME ['as' NAME]
        mark = self._mark()
        if (
            (a := self.name())
            and
            (b := self._tmp_7(),)
        ):
            return builder . build_import_member ( a , b )
        self._reset(mark)
        return None

    @memoize
    def expression(self) -> Optional[Any]:
        # expression: &'(' NL? inline_function | if_else
        mark = self._mark()
        if (
            self.positive_lookahead(self.expect, '(')
            and
            (opt := self.NL(),)
            and
            (inline_function := self.inline_function())
        ):
            return inline_function
        self._reset(mark)
        if (
            (if_else := self.if_else())
        ):
            return if_else
        self._reset(mark)
        return None

    @memoize
    def if_else(self) -> Optional[Any]:
        # if_else: disjunction NL? '?' NL? if_else NL? ':' NL? expression | disjunction
        mark = self._mark()
        if (
            (a := self.disjunction())
            and
            (opt := self.NL(),)
            and
            (t := self.expect('?'))
            and
            (opt_1 := self.NL(),)
            and
            (b := self.if_else())
            and
            (opt_2 := self.NL(),)
            and
            (literal := self.expect(':'))
            and
            (opt_3 := self.NL(),)
            and
            (c := self.expression())
        ):
            return builder . build_if_else ( a , b , c , t )
        self._reset(mark)
        if (
            (disjunction := self.disjunction())
        ):
            return disjunction
        self._reset(mark)
        return None

    @memoize
    def disjunction(self) -> Optional[Any]:
        # disjunction: conjunction '||' NL? or_conjunctions | conjunction
        mark = self._mark()
        if (
            (conjunction := self.conjunction())
            and
            (t := self.expect('||'))
            and
            (opt := self.NL(),)
            and
            (or_conjunctions := self.or_conjunctions())
        ):
            return builder . build_binary_operation ( 'or' , [conjunction] + or_conjunctions [0] , [t] + or_conjunctions [1] )
        self._reset(mark)
        if (
            (conjunction := self.conjunction())
        ):
            return conjunction
        self._reset(mark)
        return None

    @memoize
    def or_conjunctions(self) -> Optional[Any]:
        # or_conjunctions: conjunction '||' NL? or_conjunctions | conjunction
        mark = self._mark()
        if (
            (conjunction := self.conjunction())
            and
            (t := self.expect('||'))
            and
            (opt := self.NL(),)
            and
            (or_conjunctions := self.or_conjunctions())
        ):
            return ( [conjunction] + or_conjunctions [0] , [t] + or_conjunctions [1] )
        self._reset(mark)
        if (
            (conjunction := self.conjunction())
        ):
            return ( [conjunction] , [] )
        self._reset(mark)
        return None

    @memoize
    def conjunction(self) -> Optional[Any]:
        # conjunction: comparisons '&&' NL? and_comparisons | comparisons
        mark = self._mark()
        if (
            (comparisons := self.comparisons())
            and
            (t := self.expect('&&'))
            and
            (opt := self.NL(),)
            and
            (and_comparisons := self.and_comparisons())
        ):
            return builder . build_binary_operation ( 'and' , [comparisons] + and_comparisons [0] , [t] + and_comparisons [1] )
        self._reset(mark)
        if (
            (comparisons := self.comparisons())
        ):
            return comparisons
        self._reset(mark)
        return None

    @memoize
    def and_comparisons(self) -> Optional[Any]:
        # and_comparisons: comparisons '&&' NL? and_comparisons | comparisons
        mark = self._mark()
        if (
            (comparisons := self.comparisons())
            and
            (t := self.expect('&&'))
            and
            (opt := self.NL(),)
            and
            (and_comparisons := self.and_comparisons())
        ):
            return ( [comparisons] + and_comparisons [0] , [t] + and_comparisons [1] )
        self._reset(mark)
        if (
            (comparisons := self.comparisons())
        ):
            return ( [comparisons] , [] )
        self._reset(mark)
        return None

    @memoize
    def comparisons(self) -> Optional[Any]:
        # comparisons: bitwise_or compare_op_bitwise_or_pairs | bitwise_or
        mark = self._mark()
        if (
            (bitwise_or := self.bitwise_or())
            and
            (compare_op_bitwise_or_pairs := self.compare_op_bitwise_or_pairs())
        ):
            return builder . build_binary_operation ( compare_op_bitwise_or_pairs ["ops"] , [bitwise_or] + compare_op_bitwise_or_pairs ["comp"] , compare_op_bitwise_or_pairs ["tok"] )
        self._reset(mark)
        if (
            (bitwise_or := self.bitwise_or())
        ):
            return bitwise_or
        self._reset(mark)
        return None

    @memoize
    def compare_op_bitwise_or_pairs(self) -> Optional[Any]:
        # compare_op_bitwise_or_pairs: compare_op_bitwise_or_pair compare_op_bitwise_or_pairs | compare_op_bitwise_or_pair
        mark = self._mark()
        if (
            (compare_op_bitwise_or_pair := self.compare_op_bitwise_or_pair())
            and
            (compare_op_bitwise_or_pairs := self.compare_op_bitwise_or_pairs())
        ):
            return {"ops" : [compare_op_bitwise_or_pair [0]] + compare_op_bitwise_or_pairs ["ops"] , "comp" : [compare_op_bitwise_or_pair [1]] + compare_op_bitwise_or_pairs ["comp"] , "tok" : [compare_op_bitwise_or_pair [2]] + compare_op_bitwise_or_pairs ["tok"]}
        self._reset(mark)
        if (
            (compare_op_bitwise_or_pair := self.compare_op_bitwise_or_pair())
        ):
            return {"ops" : [compare_op_bitwise_or_pair [0]] , "comp" : [compare_op_bitwise_or_pair [1]] , "tok" : [compare_op_bitwise_or_pair [2]]}
        self._reset(mark)
        return None

    @memoize
    def compare_op_bitwise_or_pair(self) -> Optional[Any]:
        # compare_op_bitwise_or_pair: eq_bitwise_or | noteq_bitwise_or | lte_bitwise_or | lt_bitwise_or | gte_bitwise_or | gt_bitwise_or | notin_bitwise_or | in_bitwise_or
        mark = self._mark()
        if (
            (eq_bitwise_or := self.eq_bitwise_or())
        ):
            return eq_bitwise_or
        self._reset(mark)
        if (
            (noteq_bitwise_or := self.noteq_bitwise_or())
        ):
            return noteq_bitwise_or
        self._reset(mark)
        if (
            (lte_bitwise_or := self.lte_bitwise_or())
        ):
            return lte_bitwise_or
        self._reset(mark)
        if (
            (lt_bitwise_or := self.lt_bitwise_or())
        ):
            return lt_bitwise_or
        self._reset(mark)
        if (
            (gte_bitwise_or := self.gte_bitwise_or())
        ):
            return gte_bitwise_or
        self._reset(mark)
        if (
            (gt_bitwise_or := self.gt_bitwise_or())
        ):
            return gt_bitwise_or
        self._reset(mark)
        if (
            (notin_bitwise_or := self.notin_bitwise_or())
        ):
            return notin_bitwise_or
        self._reset(mark)
        if (
            (in_bitwise_or := self.in_bitwise_or())
        ):
            return in_bitwise_or
        self._reset(mark)
        return None

    @memoize
    def eq_bitwise_or(self) -> Optional[Any]:
        # eq_bitwise_or: '==' NL? bitwise_or
        mark = self._mark()
        if (
            (t := self.expect('=='))
            and
            (opt := self.NL(),)
            and
            (bitwise_or := self.bitwise_or())
        ):
            return 'eq' , bitwise_or , t
        self._reset(mark)
        return None

    @memoize
    def noteq_bitwise_or(self) -> Optional[Any]:
        # noteq_bitwise_or: ('!=') NL? bitwise_or
        mark = self._mark()
        if (
            (t := self.expect('!='))
            and
            (opt := self.NL(),)
            and
            (bitwise_or := self.bitwise_or())
        ):
            return 'ne' , bitwise_or , t
        self._reset(mark)
        return None

    @memoize
    def lte_bitwise_or(self) -> Optional[Any]:
        # lte_bitwise_or: '<=' NL? bitwise_or
        mark = self._mark()
        if (
            (t := self.expect('<='))
            and
            (opt := self.NL(),)
            and
            (bitwise_or := self.bitwise_or())
        ):
            return 'lte' , bitwise_or , t
        self._reset(mark)
        return None

    @memoize
    def lt_bitwise_or(self) -> Optional[Any]:
        # lt_bitwise_or: '<' NL? bitwise_or
        mark = self._mark()
        if (
            (t := self.expect('<'))
            and
            (opt := self.NL(),)
            and
            (bitwise_or := self.bitwise_or())
        ):
            return 'lt' , bitwise_or , t
        self._reset(mark)
        return None

    @memoize
    def gte_bitwise_or(self) -> Optional[Any]:
        # gte_bitwise_or: '>=' NL? bitwise_or
        mark = self._mark()
        if (
            (t := self.expect('>='))
            and
            (opt := self.NL(),)
            and
            (bitwise_or := self.bitwise_or())
        ):
            return 'gte' , bitwise_or , t
        self._reset(mark)
        return None

    @memoize
    def gt_bitwise_or(self) -> Optional[Any]:
        # gt_bitwise_or: '>' NL? bitwise_or
        mark = self._mark()
        if (
            (t := self.expect('>'))
            and
            (opt := self.NL(),)
            and
            (bitwise_or := self.bitwise_or())
        ):
            return 'gt' , bitwise_or , t
        self._reset(mark)
        return None

    @memoize
    def notin_bitwise_or(self) -> Optional[Any]:
        # notin_bitwise_or: 'not' 'in' NL? bitwise_or
        mark = self._mark()
        if (
            (t := self.expect('not'))
            and
            (literal := self.expect('in'))
            and
            (opt := self.NL(),)
            and
            (bitwise_or := self.bitwise_or())
        ):
            return 'not in' , bitwise_or , t
        self._reset(mark)
        return None

    @memoize
    def in_bitwise_or(self) -> Optional[Any]:
        # in_bitwise_or: 'in' NL? bitwise_or
        mark = self._mark()
        if (
            (t := self.expect('in'))
            and
            (opt := self.NL(),)
            and
            (bitwise_or := self.bitwise_or())
        ):
            return 'in' , bitwise_or , t
        self._reset(mark)
        return None

    @memoize_left_rec
    def bitwise_or(self) -> Optional[Any]:
        # bitwise_or: bitwise_or '|' NL? !'|' bitwise_xor | bitwise_xor
        mark = self._mark()
        if (
            (bitwise_or := self.bitwise_or())
            and
            (literal := self.expect('|'))
            and
            (opt := self.NL(),)
            and
            self.negative_lookahead(self.expect, '|')
            and
            (bitwise_xor := self.bitwise_xor())
        ):
            return BinOp ( bitwise_or , '|' , bitwise_xor )
        self._reset(mark)
        if (
            (bitwise_xor := self.bitwise_xor())
        ):
            return bitwise_xor
        self._reset(mark)
        return None

    @memoize_left_rec
    def bitwise_xor(self) -> Optional[Any]:
        # bitwise_xor: bitwise_xor '^' NL? bitwise_and | bitwise_and
        mark = self._mark()
        if (
            (bitwise_xor := self.bitwise_xor())
            and
            (literal := self.expect('^'))
            and
            (opt := self.NL(),)
            and
            (bitwise_and := self.bitwise_and())
        ):
            return BinOp ( bitwise_xor , '^' , bitwise_and )
        self._reset(mark)
        if (
            (bitwise_and := self.bitwise_and())
        ):
            return bitwise_and
        self._reset(mark)
        return None

    @memoize_left_rec
    def bitwise_and(self) -> Optional[Any]:
        # bitwise_and: bitwise_and '&' NL? !'&' shift_expr | shift_expr
        mark = self._mark()
        if (
            (bitwise_and := self.bitwise_and())
            and
            (literal := self.expect('&'))
            and
            (opt := self.NL(),)
            and
            self.negative_lookahead(self.expect, '&')
            and
            (shift_expr := self.shift_expr())
        ):
            return BinOp ( bitwise_and , '&' , shift_expr )
        self._reset(mark)
        if (
            (shift_expr := self.shift_expr())
        ):
            return shift_expr
        self._reset(mark)
        return None

    @memoize_left_rec
    def shift_expr(self) -> Optional[Any]:
        # shift_expr: shift_expr '<<' sum | shift_expr '>>' sum | sum
        mark = self._mark()
        if (
            (shift_expr := self.shift_expr())
            and
            (literal := self.expect('<<'))
            and
            (sum := self.sum())
        ):
            return BinOp ( shift_expr , '<<' , sum )
        self._reset(mark)
        if (
            (shift_expr := self.shift_expr())
            and
            (literal := self.expect('>>'))
            and
            (sum := self.sum())
        ):
            return BinOp ( shift_expr , '>>' , sum )
        self._reset(mark)
        if (
            (sum := self.sum())
        ):
            return sum
        self._reset(mark)
        return None

    @memoize_left_rec
    def sum(self) -> Optional[Any]:
        # sum: sum '+' NL? term | sum '-' NL? term | term
        mark = self._mark()
        if (
            (sum := self.sum())
            and
            (t := self.expect('+'))
            and
            (opt := self.NL(),)
            and
            (term := self.term())
        ):
            return builder . build_sum ( sum , term , t )
        self._reset(mark)
        if (
            (sum := self.sum())
            and
            (t := self.expect('-'))
            and
            (opt := self.NL(),)
            and
            (term := self.term())
        ):
            return builder . build_subtraction ( sum , term , t )
        self._reset(mark)
        if (
            (term := self.term())
        ):
            return term
        self._reset(mark)
        return None

    @memoize_left_rec
    def term(self) -> Optional[Any]:
        # term: term '*' NL? factor | term '/' NL? factor | term '//' NL? factor | term '%' NL? factor | factor
        mark = self._mark()
        if (
            (term := self.term())
            and
            (literal := self.expect('*'))
            and
            (opt := self.NL(),)
            and
            (factor := self.factor())
        ):
            return BinOp ( term , '*' , factor )
        self._reset(mark)
        if (
            (term := self.term())
            and
            (literal := self.expect('/'))
            and
            (opt := self.NL(),)
            and
            (factor := self.factor())
        ):
            return BinOp ( term , '/' , factor )
        self._reset(mark)
        if (
            (term := self.term())
            and
            (literal := self.expect('//'))
            and
            (opt := self.NL(),)
            and
            (factor := self.factor())
        ):
            return BinOp ( term , '//' , factor )
        self._reset(mark)
        if (
            (term := self.term())
            and
            (literal := self.expect('%'))
            and
            (opt := self.NL(),)
            and
            (factor := self.factor())
        ):
            return BinOp ( term , '%' , factor )
        self._reset(mark)
        if (
            (factor := self.factor())
        ):
            return factor
        self._reset(mark)
        return None

    @memoize
    def factor(self) -> Optional[Any]:
        # factor: '!' NL? factor | '+' NL? factor | '-' NL? factor | '~' NL? factor | power
        mark = self._mark()
        if (
            (t := self.expect('!'))
            and
            (opt := self.NL(),)
            and
            (factor := self.factor())
        ):
            return builder . build_not ( factor , t )
        self._reset(mark)
        if (
            (t := self.expect('+'))
            and
            (opt := self.NL(),)
            and
            (factor := self.factor())
        ):
            return builder . build_unary_plus ( factor , t )
        self._reset(mark)
        if (
            (t := self.expect('-'))
            and
            (opt := self.NL(),)
            and
            (factor := self.factor())
        ):
            return UnaryOp ( '-' , factor )
        self._reset(mark)
        if (
            (t := self.expect('~'))
            and
            (opt := self.NL(),)
            and
            (factor := self.factor())
        ):
            return UnaryOp ( '~' , factor )
        self._reset(mark)
        if (
            (power := self.power())
        ):
            return power
        self._reset(mark)
        return None

    @memoize
    def power(self) -> Optional[Any]:
        # power: primary '**' NL? factor | primary
        mark = self._mark()
        if (
            (primary := self.primary())
            and
            (literal := self.expect('**'))
            and
            (opt := self.NL(),)
            and
            (factor := self.factor())
        ):
            return BinOp ( primary , '**' , factor )
        self._reset(mark)
        if (
            (primary := self.primary())
        ):
            return primary
        self._reset(mark)
        return None

    @memoize_left_rec
    def primary(self) -> Optional[Any]:
        # primary: primary NL? '.' NL? reverse_call_tail | call | primary '[' NL? expression NL? ']' | atom
        mark = self._mark()
        if (
            (primary := self.primary())
            and
            (opt := self.NL(),)
            and
            (t := self.expect('.'))
            and
            (opt_1 := self.NL(),)
            and
            (a := self.reverse_call_tail())
        ):
            return builder . build_call ( a [0] , [primary] + a [1] , a [2] or t )
        self._reset(mark)
        if (
            (call := self.call())
        ):
            return call
        self._reset(mark)
        if (
            (primary := self.primary())
            and
            (t := self.expect('['))
            and
            (opt := self.NL(),)
            and
            (expression := self.expression())
            and
            (opt_1 := self.NL(),)
            and
            (literal := self.expect(']'))
        ):
            return builder . build_index_access ( primary , expression , t )
        self._reset(mark)
        if (
            (atom := self.atom())
        ):
            return atom
        self._reset(mark)
        return None

    @logger
    def call(self) -> Optional[Any]:
        # call: primary '(' NL? [arguments NL? [',' NL?]] ')'
        mark = self._mark()
        if (
            (primary := self.primary())
            and
            (t := self.expect('('))
            and
            (opt := self.NL(),)
            and
            (a := self._tmp_8(),)
            and
            (literal := self.expect(')'))
        ):
            return builder . build_call ( primary , a or [] , t )
        self._reset(mark)
        return None

    @memoize
    def arguments(self) -> Optional[Any]:
        # arguments: kwargs | (',' NL?).arg+ [NL? ',' NL? kwargs]
        mark = self._mark()
        if (
            (kwargs := self.kwargs())
        ):
            return kwargs
        self._reset(mark)
        if (
            (a := self._gather_9())
            and
            (b := self._tmp_11(),)
        ):
            return a + ( b or [] )
        self._reset(mark)
        return None

    @memoize
    def arg(self) -> Optional[Any]:
        # arg: expression !'='
        mark = self._mark()
        if (
            (expression := self.expression())
            and
            self.negative_lookahead(self.expect, '=')
        ):
            return expression
        self._reset(mark)
        return None

    @memoize
    def kwargs(self) -> Optional[Any]:
        # kwargs: (',' NL?).kwarg+
        mark = self._mark()
        if (
            (a := self._gather_12())
        ):
            return a
        self._reset(mark)
        return None

    @memoize
    def kwarg(self) -> Optional[Any]:
        # kwarg: NAME '=' NL? expression
        mark = self._mark()
        if (
            (n := self.name())
            and
            (literal := self.expect('='))
            and
            (opt := self.NL(),)
            and
            (a := self.expression())
        ):
            return ( n , a )
        self._reset(mark)
        return None

    @memoize
    def reverse_call_tail(self) -> Optional[Any]:
        # reverse_call_tail: atom '(' NL? arguments NL? [',' NL?] ')' | atom
        mark = self._mark()
        if (
            (atom := self.atom())
            and
            (t := self.expect('('))
            and
            (opt := self.NL(),)
            and
            (a := self.arguments())
            and
            (opt_1 := self.NL(),)
            and
            (opt_2 := self._tmp_14(),)
            and
            (literal := self.expect(')'))
        ):
            return ( atom , a , t )
        self._reset(mark)
        if (
            (atom := self.atom())
        ):
            return ( atom , [] , None )
        self._reset(mark)
        return None

    @memoize
    def inline_function(self) -> Optional[Any]:
        # inline_function: '(' NL? [(',' NL?).inline_function_param+ NL?] ')' NL? '=>' NL? expression
        mark = self._mark()
        if (
            (t := self.expect('('))
            and
            (opt := self.NL(),)
            and
            (a := self._tmp_15(),)
            and
            (literal := self.expect(')'))
            and
            (opt_1 := self.NL(),)
            and
            (literal_1 := self.expect('=>'))
            and
            (opt_2 := self.NL(),)
            and
            (b := self.expression())
        ):
            return builder . build_inline_function ( a or [] , b , r , t )
        self._reset(mark)
        return None

    @memoize
    def inline_function_param(self) -> Optional[Any]:
        # inline_function_param: NAME
        mark = self._mark()
        if (
            (n := self.name())
        ):
            return builder . build_inline_function_param ( n , t )
        self._reset(mark)
        return None

    @memoize
    def slices(self) -> Optional[Any]:
        # slices: slice ',' slices | slice !','
        mark = self._mark()
        if (
            (slice := self.slice())
            and
            (literal := self.expect(','))
            and
            (slices := self.slices())
        ):
            return [slice] + slices
        self._reset(mark)
        if (
            (slice := self.slice())
            and
            self.negative_lookahead(self.expect, ',')
        ):
            return [slice]
        self._reset(mark)
        return None

    @memoize
    def slice(self) -> Optional[Any]:
        # slice: expression? ':' expression? [':' expression?] | expression
        mark = self._mark()
        if (
            (l := self.expression(),)
            and
            (literal := self.expect(':'))
            and
            (u := self.expression(),)
            and
            (s := self._tmp_16(),)
        ):
            return Slice ( l , u , s [1] if s else None )
        self._reset(mark)
        if (
            (expression := self.expression())
        ):
            return expression
        self._reset(mark)
        return None

    @memoize
    def atom(self) -> Optional[Any]:
        # atom: 'true' | 'false' | 'void' | switch | member_access | "'" NAME | NAME | strings | NUMBER | list | group | '...'
        mark = self._mark()
        if (
            (t := self.expect('true'))
        ):
            return builder . build_boolean_literal ( t , True )
        self._reset(mark)
        if (
            (t := self.expect('false'))
        ):
            return builder . build_boolean_literal ( t , False )
        self._reset(mark)
        if (
            (t := self.expect('void'))
        ):
            return builder . build_void_literal ( t )
        self._reset(mark)
        if (
            (t := self.switch())
        ):
            return t
        self._reset(mark)
        if (
            (a := self.member_access())
        ):
            return a
        self._reset(mark)
        if (
            (q := self.expect("'"))
            and
            (a := self.name())
        ):
            return builder . build_literal_identifier ( a , q )
        self._reset(mark)
        if (
            (a := self.name())
        ):
            return builder . build_identifier ( a )
        self._reset(mark)
        if (
            (strings := self.strings())
        ):
            return builder . build_string_literal ( strings )
        self._reset(mark)
        if (
            (t := self.number())
        ):
            return builder . build_number_literal ( t )
        self._reset(mark)
        if (
            (list := self.list())
        ):
            return list
        self._reset(mark)
        if (
            (group := self.group())
        ):
            return group
        self._reset(mark)
        if (
            (literal := self.expect('...'))
        ):
            return literal
        self._reset(mark)
        return None

    @memoize
    def switch(self) -> Optional[Any]:
        # switch: 'switch' NL? if_else NL? '{' NL? NL.switch_case+ NL? '}'
        mark = self._mark()
        if (
            (t := self.expect('switch'))
            and
            (opt := self.NL(),)
            and
            (test := self.if_else())
            and
            (opt_1 := self.NL(),)
            and
            (literal := self.expect('{'))
            and
            (opt_2 := self.NL(),)
            and
            (cases := self._gather_17())
            and
            (opt_3 := self.NL(),)
            and
            (literal_1 := self.expect('}'))
        ):
            return builder . build_switch ( test , cases , t )
        self._reset(mark)
        return None

    @memoize
    def switch_case(self) -> Optional[Any]:
        # switch_case: '|' NL? expression NL? '=>' NL? expression
        mark = self._mark()
        if (
            (literal := self.expect('|'))
            and
            (opt := self.NL(),)
            and
            (a := self.expression())
            and
            (opt_1 := self.NL(),)
            and
            (literal_1 := self.expect('=>'))
            and
            (opt_2 := self.NL(),)
            and
            (b := self.expression())
        ):
            return builder . build_switch_case ( a , b )
        self._reset(mark)
        return None

    @memoize
    def member_access(self) -> Optional[Any]:
        # member_access: NAME '::' NL? NAME
        mark = self._mark()
        if (
            (a := self.name())
            and
            (t := self.expect('::'))
            and
            (opt := self.NL(),)
            and
            (b := self.name())
        ):
            return builder . build_member_access ( a , b , t )
        self._reset(mark)
        return None

    @memoize
    def edge(self) -> Optional[Any]:
        # edge: NAME NL? ":" NL? expression | NAME
        mark = self._mark()
        if (
            (n := self.name())
            and
            (opt := self.NL(),)
            and
            (literal := self.expect(":"))
            and
            (opt_1 := self.NL(),)
            and
            (expression := self.expression())
        ):
            return builder . build_edge ( n , expression )
        self._reset(mark)
        if (
            (n := self.name())
        ):
            return builder . build_edge ( n , builder . build_identifier ( n ) )
        self._reset(mark)
        return None

    @memoize
    def strings(self) -> Optional[Any]:
        # strings: STRING strings | STRING | '`' STRING '`'
        mark = self._mark()
        if (
            (t := self.string())
            and
            (strings := self.strings())
        ):
            return [t] + strings
        self._reset(mark)
        if (
            (t := self.string())
        ):
            return [t]
        self._reset(mark)
        if (
            (literal := self.expect('`'))
            and
            (t := self.string())
            and
            (literal_1 := self.expect('`'))
        ):
            return [t]
        self._reset(mark)
        return None

    @memoize
    def list(self) -> Optional[Any]:
        # list: '[' NL? [(',' NL?).expression+ NL? [',' NL?]] NL? ']'
        mark = self._mark()
        if (
            (t := self.expect('['))
            and
            (opt := self.NL(),)
            and
            (a := self._tmp_19(),)
            and
            (opt_1 := self.NL(),)
            and
            (literal := self.expect(']'))
        ):
            return builder . build_list ( a or [] , t )
        self._reset(mark)
        return None

    @memoize
    def group(self) -> Optional[Any]:
        # group: '(' NL? expression NL? ')'
        mark = self._mark()
        if (
            (literal := self.expect('('))
            and
            (opt := self.NL(),)
            and
            (expression := self.expression())
            and
            (opt_1 := self.NL(),)
            and
            (literal_1 := self.expect(')'))
        ):
            return expression
        self._reset(mark)
        return None

    @memoize
    def _loop0_2(self) -> Optional[Any]:
        # _loop0_2: NL definition
        mark = self._mark()
        children = []
        while (
            (NL := self.NL())
            and
            (elem := self.definition())
        ):
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_1(self) -> Optional[Any]:
        # _gather_1: definition _loop0_2
        mark = self._mark()
        if (
            (elem := self.definition())
            is not None
            and
            (seq := self._loop0_2())
            is not None
        ):
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _tmp_3(self) -> Optional[Any]:
        # _tmp_3: NL.block+ NL?
        mark = self._mark()
        if (
            (k := self._gather_20())
            and
            (opt := self.NL(),)
        ):
            return k
        self._reset(mark)
        return None

    @memoize
    def _tmp_4(self) -> Optional[Any]:
        # _tmp_4: NL? '{' NL? [NL.block+ NL?] '}'
        mark = self._mark()
        if (
            (opt := self.NL(),)
            and
            (literal := self.expect('{'))
            and
            (opt_1 := self.NL(),)
            and
            (k := self._tmp_22(),)
            and
            (literal_1 := self.expect('}'))
        ):
            return k
        self._reset(mark)
        return None

    @memoize
    def _loop0_6(self) -> Optional[Any]:
        # _loop0_6: ',' import_member
        mark = self._mark()
        children = []
        while (
            (literal := self.expect(','))
            and
            (elem := self.import_member())
        ):
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_5(self) -> Optional[Any]:
        # _gather_5: import_member _loop0_6
        mark = self._mark()
        if (
            (elem := self.import_member())
            is not None
            and
            (seq := self._loop0_6())
            is not None
        ):
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _tmp_7(self) -> Optional[Any]:
        # _tmp_7: 'as' NAME
        mark = self._mark()
        if (
            (literal := self.expect('as'))
            and
            (k := self.name())
        ):
            return k
        self._reset(mark)
        return None

    @memoize
    def _tmp_8(self) -> Optional[Any]:
        # _tmp_8: arguments NL? [',' NL?]
        mark = self._mark()
        if (
            (k := self.arguments())
            and
            (opt := self.NL(),)
            and
            (opt_1 := self._tmp_23(),)
        ):
            return k
        self._reset(mark)
        return None

    @memoize
    def _loop0_10(self) -> Optional[Any]:
        # _loop0_10: (',' NL?) arg
        mark = self._mark()
        children = []
        while (
            (_tmp_24 := self._tmp_24())
            and
            (elem := self.arg())
        ):
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_9(self) -> Optional[Any]:
        # _gather_9: arg _loop0_10
        mark = self._mark()
        if (
            (elem := self.arg())
            is not None
            and
            (seq := self._loop0_10())
            is not None
        ):
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _tmp_11(self) -> Optional[Any]:
        # _tmp_11: NL? ',' NL? kwargs
        mark = self._mark()
        if (
            (opt := self.NL(),)
            and
            (literal := self.expect(','))
            and
            (opt_1 := self.NL(),)
            and
            (k := self.kwargs())
        ):
            return k
        self._reset(mark)
        return None

    @memoize
    def _loop0_13(self) -> Optional[Any]:
        # _loop0_13: (',' NL?) kwarg
        mark = self._mark()
        children = []
        while (
            (_tmp_25 := self._tmp_25())
            and
            (elem := self.kwarg())
        ):
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_12(self) -> Optional[Any]:
        # _gather_12: kwarg _loop0_13
        mark = self._mark()
        if (
            (elem := self.kwarg())
            is not None
            and
            (seq := self._loop0_13())
            is not None
        ):
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _tmp_14(self) -> Optional[Any]:
        # _tmp_14: ',' NL?
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (opt := self.NL(),)
        ):
            return [literal, opt]
        self._reset(mark)
        return None

    @memoize
    def _tmp_15(self) -> Optional[Any]:
        # _tmp_15: (',' NL?).inline_function_param+ NL?
        mark = self._mark()
        if (
            (k := self._gather_26())
            and
            (opt := self.NL(),)
        ):
            return k
        self._reset(mark)
        return None

    @memoize
    def _tmp_16(self) -> Optional[Any]:
        # _tmp_16: ':' expression?
        mark = self._mark()
        if (
            (literal := self.expect(':'))
            and
            (opt := self.expression(),)
        ):
            return [literal, opt]
        self._reset(mark)
        return None

    @memoize
    def _loop0_18(self) -> Optional[Any]:
        # _loop0_18: NL switch_case
        mark = self._mark()
        children = []
        while (
            (NL := self.NL())
            and
            (elem := self.switch_case())
        ):
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_17(self) -> Optional[Any]:
        # _gather_17: switch_case _loop0_18
        mark = self._mark()
        if (
            (elem := self.switch_case())
            is not None
            and
            (seq := self._loop0_18())
            is not None
        ):
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _tmp_19(self) -> Optional[Any]:
        # _tmp_19: (',' NL?).expression+ NL? [',' NL?]
        mark = self._mark()
        if (
            (k := self._gather_28())
            and
            (opt := self.NL(),)
            and
            (opt_1 := self._tmp_30(),)
        ):
            return k
        self._reset(mark)
        return None

    @memoize
    def _loop0_21(self) -> Optional[Any]:
        # _loop0_21: NL block
        mark = self._mark()
        children = []
        while (
            (NL := self.NL())
            and
            (elem := self.block())
        ):
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_20(self) -> Optional[Any]:
        # _gather_20: block _loop0_21
        mark = self._mark()
        if (
            (elem := self.block())
            is not None
            and
            (seq := self._loop0_21())
            is not None
        ):
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _tmp_22(self) -> Optional[Any]:
        # _tmp_22: NL.block+ NL?
        mark = self._mark()
        if (
            (k := self._gather_31())
            and
            (opt := self.NL(),)
        ):
            return k
        self._reset(mark)
        return None

    @memoize
    def _tmp_23(self) -> Optional[Any]:
        # _tmp_23: ',' NL?
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (opt := self.NL(),)
        ):
            return [literal, opt]
        self._reset(mark)
        return None

    @memoize
    def _tmp_24(self) -> Optional[Any]:
        # _tmp_24: ',' NL?
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (opt := self.NL(),)
        ):
            return [literal, opt]
        self._reset(mark)
        return None

    @memoize
    def _tmp_25(self) -> Optional[Any]:
        # _tmp_25: ',' NL?
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (opt := self.NL(),)
        ):
            return [literal, opt]
        self._reset(mark)
        return None

    @memoize
    def _loop0_27(self) -> Optional[Any]:
        # _loop0_27: (',' NL?) inline_function_param
        mark = self._mark()
        children = []
        while (
            (_tmp_33 := self._tmp_33())
            and
            (elem := self.inline_function_param())
        ):
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_26(self) -> Optional[Any]:
        # _gather_26: inline_function_param _loop0_27
        mark = self._mark()
        if (
            (elem := self.inline_function_param())
            is not None
            and
            (seq := self._loop0_27())
            is not None
        ):
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _loop0_29(self) -> Optional[Any]:
        # _loop0_29: (',' NL?) expression
        mark = self._mark()
        children = []
        while (
            (_tmp_34 := self._tmp_34())
            and
            (elem := self.expression())
        ):
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_28(self) -> Optional[Any]:
        # _gather_28: expression _loop0_29
        mark = self._mark()
        if (
            (elem := self.expression())
            is not None
            and
            (seq := self._loop0_29())
            is not None
        ):
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _tmp_30(self) -> Optional[Any]:
        # _tmp_30: ',' NL?
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (opt := self.NL(),)
        ):
            return [literal, opt]
        self._reset(mark)
        return None

    @memoize
    def _loop0_32(self) -> Optional[Any]:
        # _loop0_32: NL block
        mark = self._mark()
        children = []
        while (
            (NL := self.NL())
            and
            (elem := self.block())
        ):
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_31(self) -> Optional[Any]:
        # _gather_31: block _loop0_32
        mark = self._mark()
        if (
            (elem := self.block())
            is not None
            and
            (seq := self._loop0_32())
            is not None
        ):
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _tmp_33(self) -> Optional[Any]:
        # _tmp_33: ',' NL?
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (opt := self.NL(),)
        ):
            return [literal, opt]
        self._reset(mark)
        return None

    @memoize
    def _tmp_34(self) -> Optional[Any]:
        # _tmp_34: ',' NL?
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (opt := self.NL(),)
        ):
            return [literal, opt]
        self._reset(mark)
        return None

    KEYWORDS = ('as', 'in', 'true', 'false', 'not', 'void', 'switch')
    SOFT_KEYWORDS = ('from', 'import')


if __name__ == '__main__':
    from my_pegen.parser import simple_parser_main
    simple_parser_main(BlocksParser)
