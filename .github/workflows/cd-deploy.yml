name: Deploy Affected Applications

on:
  push:
    branches: [ main ]
    paths: [ 'apps/**' ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAMESPACE: ${{ github.repository_owner }}
  VPS_HOST_SECRET: VPS_HOSTINGER_HOST
  VPS_USER_SECRET: VPS_HOSTINGER_USER
  VPS_KEY_SECRET: VPS_HOSTINGER_KEY

jobs:
  check_affected:
    # ... (definido en la respuesta anterior, sin cambios) ...
    name: Check Affected Apps
    runs-on: ubuntu-latest
    outputs:
      affected_projects: ${{ steps.get_affected.outputs.affected_projects }}
      has_affected: ${{ steps.get_affected.outputs.has_affected }}
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }
      - uses: actions/setup-node@v4
        with: { node-version: '20' }
      - run: npm ci
      - uses: nrwl/nx-set-shas@v3 # o nx/nx-set-shas@v4
        with: { main-branch-name: 'main' }
      - name: Get Affected Projects
        id: get_affected
        run: |
          echo "NX_BASE SHA: ${{ env.NX_BASE }}" # Debug: Print base SHA
          echo "NX_HEAD SHA: ${{ env.NX_HEAD }}" # Debug: Print head SHA

          # Ejecuta nx affected, capturando stdout Y stderr (2>&1)
          AFFECTED_OUTPUT=$(npx nx affected --target=deploy-info --base=${{ env.NX_BASE }} --head=${{ env.NX_HEAD }} --json 2>&1)
          NX_EXIT_CODE=$? # Captura el código de salida del comando nx

          echo "Raw Affected Output (incl. stderr): [$AFFECTED_OUTPUT]" # Added brackets for clarity
          echo "NX Exit Code: $NX_EXIT_CODE" # Debug: Muestra el código de salida

          # Verifica si el comando nx falló explícitamente
          if [ $NX_EXIT_CODE -ne 0 ]; then
            echo "::error::nx affected command failed with exit code $NX_EXIT_CODE."
            exit $NX_EXIT_CODE
          fi

          # --- Inicio: Lógica robusta para manejar salida ---
          AFFECTED_PROJECTS="[]" # Default to empty JSON array
          HAS_AFFECTED="false"

          # 1. Comprobar si la salida está completamente vacía
          if [ -z "$AFFECTED_OUTPUT" ]; then
              echo "nx affected output is empty. Assuming no projects affected."
          # 2. Si no está vacía, comprobar si es JSON válido
          elif ! echo "$AFFECTED_OUTPUT" | jq -e . > /dev/null; then
              # Podría ser un mensaje de advertencia/error de Nx en lugar de JSON
              echo "::warning::nx affected output is not valid JSON. Assuming no projects affected."
              # Considera fallar si siempre esperas JSON:
              # echo "::error::nx affected output is not valid JSON."
              # exit 1
          # 3. Si es JSON válido, intentar extraer '.projects'
          else
              # Extraer el array .projects, con fallback a [] si .projects es null o no existe
              TEMP_PROJECTS=$(echo "$AFFECTED_OUTPUT" | jq -c '.projects // []')
              # Comprobar si el array extraído no está vacío o nulo
              if [ "$TEMP_PROJECTS" != "[]" ] && [ "$TEMP_PROJECTS" != "null" ] ; then
                   AFFECTED_PROJECTS="$TEMP_PROJECTS"
                   HAS_AFFECTED="true"
                   echo "Successfully extracted affected projects."
              else
                   echo "JSON output received, but '.projects' array is empty or null. No projects affected."
              fi
          fi
          # --- Fin: Lógica robusta ---

          echo "Affected Projects JSON: $AFFECTED_PROJECTS"
          echo "Has Affected: $HAS_AFFECTED"
          echo "affected_projects=$AFFECTED_PROJECTS" >> $GITHUB_OUTPUT
          echo "has_affected=$HAS_AFFECTED" >> $GITHUB_OUTPUT

  # ----- Job 2: Construir y Desplegar Aplicaciones Afectadas -----
  deploy_affected:
    name: Build and Deploy ${{ matrix.project }}
    needs: check_affected
    if: needs.check_affected.outputs.has_affected == 'true'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        project: ${{ fromJson(needs.check_affected.outputs.affected_projects) }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      # Necesitamos Node.js para ejecutar comandos nx
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Dependencies
        run: npm ci

      # Obtenemos la ruta raíz del proyecto afectado para usarla como contexto Docker
      - name: Get Project Root Path
        id: get_root
        run: |
          PROJECT_ROOT=$(nx show project ${{ matrix.project }} --json | jq -r .root)
          echo "Project Root: $PROJECT_ROOT"
          echo "root=$PROJECT_ROOT" >> $GITHUB_OUTPUT

      # --- Build y Push a GHCR ---
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GHCR_TOKEN }} # Usa el nombre de tu secreto

      - name: Generate Image Tags
        id: image_tags
        run: |
          IMAGE_NAME="${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/${{ matrix.project }}"
          # Convertir a minúsculas (requerido por Docker tags)
          IMAGE_NAME=$(echo "$IMAGE_NAME" | tr '[:upper:]' '[:lower:]')
          TAG_LATEST="${IMAGE_NAME}:latest"
          TAG_SHA="${IMAGE_NAME}:${{ github.sha }}"
          echo "tags=${TAG_LATEST},${TAG_SHA}" >> $GITHUB_OUTPUT
          echo "image_name_sha=${TAG_SHA}" >> $GITHUB_OUTPUT # Output específico con SHA
          echo "Generated Tags: ${TAG_LATEST}, ${TAG_SHA}"

      - name: Build and Push Docker image
        uses: docker/build-push-action@v6
        with:
          context: ${{ steps.get_root.outputs.root }} # Usa la ruta obtenida con nx show
          file: ${{ steps.get_root.outputs.root }}/Dockerfile # Ruta completa al Dockerfile
          push: true
          tags: ${{ steps.image_tags.outputs.tags }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # --- Despliegue en VPS ---
      - name: Setup SSH Agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets[env.VPS_KEY_SECRET] }}

      - name: Add VPS Host to Known Hosts
        run: |
          VPS_HOST="${{ secrets[env.VPS_HOST_SECRET] }}"
          if [ -z "$VPS_HOST" ]; then echo "Error: Host secret missing." >&2; exit 1; fi
          mkdir -p ~/.ssh && chmod 700 ~/.ssh
          ssh-keyscan -H "$VPS_HOST" >> ~/.ssh/known_hosts && chmod 600 ~/.ssh/known_hosts
          echo "Added $VPS_HOST to known_hosts"

      - name: Prepare Remote Environment & Deploy
        env:
          VPS_HOST: ${{ secrets[env.VPS_HOST_SECRET] }}
          VPS_USER: ${{ secrets[env.VPS_USER_SECRET] }}
          PROJECT_NAME: ${{ matrix.project }} # ej: jupiter-www
          PROJECT_ROOT_PATH: ${{ steps.get_root.outputs.root }} # ej: apps/jupiter/www
          # Imagen específica con SHA que acabamos de pushear
          APP_IMAGE_NAME_SHA: ${{ steps.image_tags.outputs.image_name_sha }}
        run: |
          # Variables
          REMOTE_USER_HOST="${VPS_USER}@${VPS_HOST}"
          REMOTE_APP_DIR="/home/${VPS_USER}/apps/${PROJECT_NAME}"
          LOCAL_COMPOSE_FILE="${PROJECT_ROOT_PATH}/docker-compose-app.yml"
          REMOTE_COMPOSE_FILE="${REMOTE_APP_DIR}/docker-compose-app.yml"
          REMOTE_ENV_FILE="${REMOTE_APP_DIR}/.env"
          ENV_VAR_NAME="APP_IMAGE_NAME" # Variable a actualizar en .env

          echo "Deploying project ${PROJECT_NAME} to ${REMOTE_USER_HOST}:${REMOTE_APP_DIR}"
          echo "Using Image: ${APP_IMAGE_NAME_SHA}"

          # 1. Crear directorio remoto (ignora error si ya existe)
          ssh "$REMOTE_USER_HOST" "mkdir -p ${REMOTE_APP_DIR}" || true

          # 2. Sincronizar docker-compose-app.yml
          echo "Syncing ${LOCAL_COMPOSE_FILE} to ${REMOTE_USER_HOST}:${REMOTE_COMPOSE_FILE}"
          rsync -avz "${LOCAL_COMPOSE_FILE}" "${REMOTE_USER_HOST}:${REMOTE_COMPOSE_FILE}" \
            || { echo "Rsync failed!"; exit 1; }

          # 3. Actualizar variable APP_IMAGE_NAME en .env remoto (de forma segura)
          echo "Updating ${ENV_VAR_NAME} in ${REMOTE_USER_HOST}:${REMOTE_ENV_FILE}"
          ssh "$REMOTE_USER_HOST" bash -s << EOF
            set -e # Exit on error
            ENV_FILE="${REMOTE_ENV_FILE}"
            VAR_NAME="${ENV_VAR_NAME}"
            VAR_VALUE="${APP_IMAGE_NAME_SHA}"

            # Crear .env si no existe
            touch "\$ENV_FILE"
            # Eliminar línea antigua si existe (ignora error si no existe)
            sed -i "/^\${VAR_NAME}=/d" "\$ENV_FILE" || true
            # Añadir nueva línea
            echo "\${VAR_NAME}=\${VAR_VALUE}" >> "\$ENV_FILE"
            echo "Updated ${ENV_VAR_NAME} in \${ENV_FILE}"
          EOF

          # 4. Ejecutar Docker Compose Remoto
          echo "Running docker compose pull & up on remote host..."
          ssh "$REMOTE_USER_HOST" bash -s << EOF
            set -e # Exit on error
            cd "${REMOTE_APP_DIR}"
            echo "[Remote] Pulling image..."
            docker compose pull # Docker Compose usará APP_IMAGE_NAME del .env para saber qué imagen bajar
            echo "[Remote] Starting application..."
            # El .env se carga automáticamente por docker compose
            docker compose -f docker-compose-app.yml up -d --remove-orphans
            echo "[Remote] Deployment complete."
          EOF
