name: Deploy Affected Applications

on:
  push:
    branches: [ main ] # O la rama que uses para desplegar
    paths:
      - 'apps/**'     # Solo se activa si hay cambios dentro de apps/

env:
  REGISTRY: ghcr.io # Usaremos GitHub Container Registry
  # El namespace suele ser el usuario u organización dueña del repo
  IMAGE_NAMESPACE: ${{ github.repository_owner }}
  # Asumimos un único VPS destino por ahora, usando los secretos de 'hostinger'
  VPS_HOST_SECRET: VPS_HOSTINGER_HOST # Nombre del secreto para el Host
  VPS_USER_SECRET: VPS_HOSTINGER_USER # Nombre del secreto para el User (deploy)
  VPS_KEY_SECRET: VPS_HOSTINGER_KEY   # Nombre del secreto para la Clave SSH Privada

jobs:
  # ----- Job 1: Determinar qué aplicaciones fueron afectadas -----
  check_affected:               # <--- Definición del Job
    name: Check Affected Apps     # <--- Nombre del Job
    runs-on: ubuntu-latest      # <--- Runner
    outputs:                      # <--- Definición de Outputs
      affected_projects: ${{ steps.get_affected.outputs.affected_projects }}
      has_affected: ${{ steps.get_affected.outputs.has_affected }}

    steps:                        # <--- Inicio de la lista de Pasos (Steps)

      - name: Checkout Repository # Paso 1: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Necesario para que Nx calcule correctamente los SHAs base/head

      - name: Setup Node.js       # Paso 2: Configurar Node
        uses: actions/setup-node@v4
        with:
          node-version: '20' # O la versión que uses

      - name: Install Dependencies  # Paso 3: Instalar dependencias
        run: npm ci # O yarn install --frozen-lockfile

      # Deriva los SHAs base y head para nx affected
      - name: Derive SHAs for Nx Affected # Paso 4: Obtener SHAs
        # Asegúrate que esta acción exista o usa una equivalente como nx/nx-set-shas@v4
        uses: nrwl/nx-set-shas@v3
        with:
           main-branch-name: 'main' # Asegúrate que coincida con tu rama base

      # Este es el paso cuyo script ya tenías, ahora correctamente ubicado
      - name: Get Affected Projects
        id: get_affected
        run: |
          set -x # Mantener para depuración por ahora

          echo "NX_BASE SHA: ${{ env.NX_BASE }}"
          echo "NX_HEAD SHA: ${{ env.NX_HEAD }}"

          # --- CAMBIO: Usar nx print-affected ---
          # Este comando debería devolver directamente un array JSON como ["proj1", "proj2"] o []
          # Capturamos solo stdout, asumimos que errores irán a stderr si falla
          AFFECTED_PROJECTS_JSON=$(npx nx print-affected --target=deploy-info --select=projects --json --base=${{ env.NX_BASE }} --head=${{ env.NX_HEAD }})
          NX_EXIT_CODE=$?
          # --- FIN CAMBIO ---

          echo "Raw Affected Projects JSON: [$AFFECTED_PROJECTS_JSON]"
          echo "NX Exit Code: $NX_EXIT_CODE"

          # Verificar si el comando nx falló explícitamente
          if [ $NX_EXIT_CODE -ne 0 ]; then
            # Intentar obtener stderr para el mensaje de error
            AFFECTED_OUTPUT_ERR=$(npx nx print-affected --target=deploy-info --select=projects --json --base=${{ env.NX_BASE }} --head=${{ env.NX_HEAD }} 2>&1) || true
            echo "::error::nx print-affected command failed with exit code $NX_EXIT_CODE. Output/Error was: $AFFECTED_OUTPUT_ERR"
            exit $NX_EXIT_CODE
          fi

          # --- Lógica simplificada para validar el array JSON ---
          AFFECTED_PROJECTS="[]" # Default
          HAS_AFFECTED="false"

          # Verificar si la salida es un array JSON con elementos
          # jq -e 'type=="array" and length > 0' devolverá 0 (éxito) si es un array no vacío, 1 (error) en caso contrario
          if echo "$AFFECTED_PROJECTS_JSON" | jq -e 'type=="array" and length > 0' > /dev/null; then
              # Es un array JSON no vacío, asignarlo (aseurando formato compacto)
              AFFECTED_PROJECTS=$(echo "$AFFECTED_PROJECTS_JSON" | jq -c .)
              HAS_AFFECTED="true"
              echo "Successfully found affected projects."
          else
              # La salida era vacía, '[]', o no era un array JSON válido (aunque exit code 0 sugiere que sí era JSON)
              echo "nx print-affected returned empty array or invalid JSON. No projects affected."
              # Mantenemos AFFECTED_PROJECTS="[]" y HAS_AFFECTED="false"
          fi
          # --- Fin lógica simplificada ---

          echo "Affected Projects JSON: $AFFECTED_PROJECTS"
          echo "Has Affected: $HAS_AFFECTED"

          echo "Setting output affected_projects=${AFFECTED_PROJECTS}"
          echo "affected_projects=$AFFECTED_PROJECTS" >> $GITHUB_OUTPUT

          echo "Setting output has_affected=${HAS_AFFECTED}"
          echo "has_affected=$HAS_AFFECTED" >> $GITHUB_OUTPUT

          echo "Finished setting outputs."
          set +x

  # ----- Job 2: Construir y Desplegar Aplicaciones Afectadas -----
  # (Esta parte parecía correcta en tu versión anterior)
  deploy_affected:
    name: Build and Deploy ${{ matrix.project }}
    needs: check_affected
    if: needs.check_affected.outputs.has_affected == 'true'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        project: ${{ fromJson(needs.check_affected.outputs.affected_projects) }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Dependencies
        run: npm ci

      - name: Get Project Root Path
        id: get_root
        run: |
          # Usamos npx para ejecutar nx show
          PROJECT_ROOT=$(npx nx show project ${{ matrix.project }} --json | jq -r .root)
          echo "Project Root: $PROJECT_ROOT"
          echo "root=$PROJECT_ROOT" >> $GITHUB_OUTPUT

      # --- Build y Push a GHCR ---
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GHCR_TOKEN }} # Asegúrate que este sea el nombre de tu secreto

      - name: Generate Image Tags
        id: image_tags
        run: |
          IMAGE_NAME="${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/${{ matrix.project }}"
          IMAGE_NAME=$(echo "$IMAGE_NAME" | tr '[:upper:]' '[:lower:]') # Convertir a minúsculas
          TAG_LATEST="${IMAGE_NAME}:latest"
          TAG_SHA="${IMAGE_NAME}:${{ github.sha }}"
          echo "tags=${TAG_LATEST},${TAG_SHA}" >> $GITHUB_OUTPUT
          echo "image_name_sha=${TAG_SHA}" >> $GITHUB_OUTPUT
          echo "Generated Tags: ${TAG_LATEST}, ${TAG_SHA}"

      - name: Build and Push Docker image
        uses: docker/build-push-action@v6
        with:
          context: ${{ steps.get_root.outputs.root }}
          file: ${{ steps.get_root.outputs.root }}/Dockerfile
          push: true
          tags: ${{ steps.image_tags.outputs.tags }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # --- Despliegue en VPS ---
      - name: Setup SSH Agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets[env.VPS_KEY_SECRET] }}

      - name: Add VPS Host to Known Hosts
        run: |
          VPS_HOST="${{ secrets[env.VPS_HOST_SECRET] }}"
          if [ -z "$VPS_HOST" ]; then echo "Error: Host secret missing." >&2; exit 1; fi
          mkdir -p ~/.ssh && chmod 700 ~/.ssh
          ssh-keyscan -H "$VPS_HOST" >> ~/.ssh/known_hosts && chmod 600 ~/.ssh/known_hosts
          echo "Added $VPS_HOST to known_hosts"

      - name: Prepare Remote Environment & Deploy
        env:
          VPS_HOST: ${{ secrets[env.VPS_HOST_SECRET] }}
          VPS_USER: ${{ secrets[env.VPS_USER_SECRET] }}
          PROJECT_NAME: ${{ matrix.project }} # ej: jupiter-www
          # Usamos la salida del step anterior directamente
          APP_IMAGE_NAME_SHA: ${{ steps.image_tags.outputs.image_name_sha }}
        run: |
          # Variables (simplificado)
          REMOTE_USER_HOST="${VPS_USER}@${VPS_HOST}"
          REMOTE_APP_DIR="/home/${VPS_USER}/apps/${PROJECT_NAME}"
          # Obtenemos la ruta local del compose file desde el step anterior
          LOCAL_COMPOSE_FILE="${{ steps.get_root.outputs.root }}/docker-compose-app.yml"
          REMOTE_COMPOSE_FILE="${REMOTE_APP_DIR}/docker-compose-app.yml"
          REMOTE_ENV_FILE="${REMOTE_APP_DIR}/.env"
          ENV_VAR_NAME="APP_IMAGE_NAME"

          echo "Deploying project ${PROJECT_NAME} to ${REMOTE_USER_HOST}:${REMOTE_APP_DIR}"
          echo "Using Image: ${APP_IMAGE_NAME_SHA}"

          # 1. Crear directorio remoto
          ssh "$REMOTE_USER_HOST" "mkdir -p ${REMOTE_APP_DIR}" || true

          # 2. Sincronizar docker-compose-app.yml
          echo "Syncing ${LOCAL_COMPOSE_FILE} to ${REMOTE_USER_HOST}:${REMOTE_COMPOSE_FILE}"
          rsync -avz "${LOCAL_COMPOSE_FILE}" "${REMOTE_USER_HOST}:${REMOTE_COMPOSE_FILE}" \
            || { echo "Rsync failed!"; exit 1; }

          # 3. Actualizar variable APP_IMAGE_NAME en .env remoto
          echo "Updating ${ENV_VAR_NAME} in ${REMOTE_USER_HOST}:${REMOTE_ENV_FILE}"
          ssh "$REMOTE_USER_HOST" bash -s << EOF
            set -e
            ENV_FILE="${REMOTE_ENV_FILE}"
            VAR_NAME="${ENV_VAR_NAME}"
            VAR_VALUE="${APP_IMAGE_NAME_SHA}" # Ya tenemos el valor exacto

            touch "\$ENV_FILE"
            sed -i "/^\${VAR_NAME}=/d" "\$ENV_FILE" || true
            echo "\${VAR_NAME}=\${VAR_VALUE}" >> "\$ENV_FILE"
            echo "Updated ${ENV_VAR_NAME} in \${ENV_FILE}"
          EOF

          # 4. Ejecutar Docker Compose Remoto
          echo "Running docker compose pull & up on remote host..."
          ssh "$REMOTE_USER_HOST" bash -s << EOF
            set -e
            cd "${REMOTE_APP_DIR}"
            echo "[Remote] Pulling image: ${APP_IMAGE_NAME_SHA}" # Usamos la variable para claridad
            # Asegurarse que docker compose use el .env
            docker compose --env-file .env pull
            echo "[Remote] Starting application via Docker Compose..."
            docker compose --env-file .env -f docker-compose-app.yml up -d --remove-orphans
            echo "[Remote] Deployment complete for ${PROJECT_NAME}."
          EOF
